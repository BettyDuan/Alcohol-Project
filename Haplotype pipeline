class Haplotype(): #public class
    
    def __init__(self, individual, population):
        self.individual = individual
        self.population = population
        self.haplotype = ''
        self.isDerived = 'a'
        self.genes = LinkedGenes()
    
    def updateHap(self, snp): #haplotype enlongation
        self.haplotype += snp
    
    def getRegion(self, start, end): #extract specific region of haplotype
        if self.checkBound(start, end) is True:
            return self.haplotype[start:end+1]
        return None

    def addRegion(self, hapRegion): #add the hapRegion to geneList
        if self.checkBound(hapRegion.start,hapRegion.stop) is True:
            self.genes.add(hapRegion)
    
    def removeRegion(self, name): #remove the hapRegion from geneList
        self.genes.delete(name)
            
    def getHapRegion(self, name): #get the hapRegion instance with the correct name (e.g.'ADH1B')
        hapRegion = self.genes.getGeneAtName(name)
        return hapRegion
        
    def setDerived(self, derivedName): #set 'd' if at specific allele is derived
        self.isDerived = derivedName #name is e.g. '2d'/'3d'
        
    def checkBound(self, start, end): #check if start and end indeces for haplotype is within bound
        if start >= 0 and end < len(self.haplotype):
            return True
        return False


class HapRegion(): #segregate the long haplotype (this is a private class)
    
    def __init__(self, start, stop):
        self.regionName = ''
        self.hapNum = -1
        self.group = -1
        self.start = start
        self.stop = stop 
    
    def setHapNum(self, number): #index number of haplotype
        self.hapNum = number
    
    def setGroup(self, group): #after clustering the group number
        self.group = group
        
    def setRegionName(self, name): #something like 'ADH1B'
        self.regionName = name
    
    def getLength(self): #length of the hapRegion
        return self.stop - self.start + 1


class LinkedGenes(): #this is a private class 
    
    def __init__(self):
        self.geneList = [] #geneList consists of HapRegion instances only!!
    
    def add(self, hapRegion):
        if self.checkIn(hapRegion.start,hapRegion.stop) is None:
            if self.geneNum() < 1:
                self.geneList.append(hapRegion)
            else:
                index = len(self.geneList)
                for i,gene in enumerate(self.geneList):
                    if hapRegion.start < gene.start:
                        index = i
                        break
                self.geneList.insert(index,hapRegion)
    
    def delete(self, name):
        gene = self.getGeneAtName(name)
        if gene is not None:
            self.geneList.remove(gene)
        
    def getGeneAtIndex(self, start, end):
        gene = self.checkIn(start,end)
        return gene
    
    def getGeneAtName(self, name):
        if self.geneNum() > 0:
            for gene in self.geneList:
                if gene.regionName == name:
                    return gene
        return None
    
    def checkIn(self, start, end): #see if a specific region is already in the geneList
        if self.geneNum() > 0:
            for gene in self.geneList:
                if start == gene.start and end == gene.stop:
                    return gene
        return None
    
    def geneNum(self):
        return len(self.geneList)
        
        
class SNP(): #This is a public class
    
    def __init__(self):
        self.snpList = []
        self.snpLetter = []
        self.snpPosition = []
    
    def appendSNP(self,snp,before,after,position):
        self.snpList.append(snp)
        self.snpLetter.append([before,after])  
        self.snpPosition.append(position)
    
    def getLength(self): #get the length of constructed haplotype class
        return len(self.snpList)
    
    def getIndexAtPos(self, position): #the coordinate of the snp
        index = None
        if position in self.snpPosition:
            index = self.snpPosition.index(position)
        return index
    
    def getIndexAtName(self, name): #the rs name of the snp
        index = None
        if name in self.snpList:
            index = self.snpList.index(name)
        return index
    
    def approximate(self, position1, position2): # find the snp closest to the position            
        beforePos,afterPos = None,None
        for i,coordinate in enumerate(self.snpPosition):
            if coordinate <= position2:
                if coordinate >= position1:
                    if i > 0:
                        beforePos = self.snpPosition[i-1]
                    else:
                        beforePos = self.snpPosition[0]
            else:
                afterPos = self.snpPosition[i-1]
                    
        return beforePos,afterPos
        
                
                

    
def ancestral(INFO,ref,ALT):
    switcher={'AA=A|':'A','AA=T|':'T','AA=C|':'C',
              'AA=G|':'G','AA=.|':'.'}
    for i,value in enumerate(switcher.keys()):
        if value in INFO:
            ancestral=switcher.get(value)
            if ancestral==ref or ancestral=='.':
                return {'1|1':['1','1'], '1|0':['1','0'], '0|1':['0','1'], '0|0':['0','0'], '.|.':['9','9']}  
            elif ancestral==ALT:
                return {'1|1':['0','0'], '1|0':['0','1'], '0|1':['1','0'], '0|0':['1','1'], '.|.':['9','9']}
            else:
                return None
    else:
        return None



def distinctHap(dic, start, end): #{h1:100,h2:53} arranged by freq from high to low
    dicHap={}
    for index in dic:
        hap=dic[index].getRegion(start,end)
        if hap not in dicHap:
            dicHap[hap]=1
        else:
            dicHap[hap]+=1
    return dict(reversed(sorted(dicHap.items(), key=lambda item: item[1])))

def nameHap(dicHap): #haplotype with the highest freqeuncy gets a smaller index number
    nameHap={}
    for i,h in enumerate(dicHap):
        nameHap[h]=i #{h1:1}!
    return nameHap
    
def findName(haplotype, nameHap): #find the index number of a haplotype
    if haplotype in nameHap:
        return nameHap[haplotype]
    else:
        return None
        
 
##for clustering

import numpy as np
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

class Kmeans():
    
    def __init__(self, dicHap):
        self.hapList = self.hapArray(dicHap)
        self.groupNum = 0
        self.clusters = []
    
    def hapArray(self, dic):
        hapList=[]
        for hap in dic:
            hap = [int(h) for h in hap]
            hapList.append(hap)
        return np.array(hapList)
    
    def findGroupNum(self):
        sumSquaredDis = []
        for number in range(1,16):
            kms = KMeans(n_clusters=number, random_state=0).fit(self.hapList)
            sumSquaredDis.append(kms.inertia_) #Sum of squared distances of samples to their closest cluster center.
        plt.plot([k for k in range(1,16)], sumSquaredDis, 'bx-')
        plt.xlabel('Number')
        plt.ylabel('Sum_of_squared_distances')
        plt.title('Elbow Method For Optimal Number of Groups')
        plt.show()
        self.groupNum = int(input('Enter the optimal number of groups: '))
    
    def kmeanCluster(self):
        km = KMeans(n_clusters=self.groupNum, random_state=0).fit(self.hapList)
        self.clusters=km.labels_
        return self.clusters
    
    def groupDic(self): #{0(group):[h1,h2]}
        dicGroup={int(i):[] for i in range(self.groupNum)}
        for i,hap in enumerate(self.hapList):
            group = self.clusters[i]
            h = ''
            for allele in hap:
                h+=str(allele)
            dicGroup[group].append(h)
        return dicGroup
        
        
def clustering(dicHap): #implement clustering class
    km = Kmeans(dicHap)
    km.findGroupNum()
    clusters=km.kmeanCluster()
    dicGroup=km.groupDic()
    return dicGroup

def findGroup(haplotype,dicGroup): #find a specific haplotype belonging in which cluster group
    for key in dicGroup:
        if haplotype in dicGroup[key]:
            return key
    else:
        return None
    
def convertdicGroup(dicHap,dicGroup):
    dicGroupKey={}
    for key in dicGroup:
        dicGroupKey[key]=[]
        haplotypes=dicGroup[key]
        for hap in haplotypes:
            index=dicHap[hap]
            dicGroupKey[key].append(index)
    return dicGroupKey
    
    
##Start creating haplotyps for 1KG
import math
from collections import Counter
import numpy as np

r1=['GWD','MSL','YRI','ESN','LWK','ACB','ASW']
r2=['MXL','PUR','CLM','PEL']
r3=['CHB','JPT','CHS','CDX','KHV']
r4=['GBR','FIN','CEU','TSI','IBS']
r5=['PJL','GIH','BEB','ITU','STU'] 
popList = r1+r2+r3+r4+r5
region={'Africa':r1,'America':r2,'East_asia':r3,'Europe':r4,'South_asia':r5}
pop_region={pop:cont for cont in region for pop in region[cont]}

dicHaplotypes={} ##{5.1:Haplotype(id,pop),5.2:Haplotype(id,pop)} important!

pwd='/home/classes/myanglab/data/1KG/'
pd='/home/classes/myanglab/Betty/'
indvdic={}
with open(pwd+'integrated_call_samples_v3.20130502.ALL.panel','r') as fileind:
    for line in fileind:
        if line.startswith('sample') is False:
            line=line.split()
            pop=line[1]
            indvid=line[0]
            indvdic[indvid]=pop

with open(pd+'1000Indiv.txt','r') as file:
    line=file.readline().split()
    dic2={(i-9):value for i, value in enumerate(line) 
            if value in indvdic.keys()}
    for i,value in enumerate(line):
        if i>=9:
            firstIndex=i+0.1
            secondIndex=i+0.2
            dicHaplotypes[firstIndex]=Haplotype(value,indvdic[value])
            dicHaplotypes[secondIndex]=Haplotype(value,indvdic[value])
        
#print(dicHaplotypes.keys())

with open('/home/classes/myanglab/Betty/Haplotype2/longer_newvcf.vcf','r') as filevcf:
    snpClass = SNP()
    for i,line in enumerate(filevcf):
        if line.startswith('#') is False:
            line=line.split() 
            position=int(line[1])
            if 100195918<= position <= 100274744: #add a bound to save more memory
                snp,ref,alt,INFO=line[2],line[3],line[4],line[7]
                snpClass.appendSNP(snp,ref,alt,position)
                switcher=ancestral(INFO,ref,alt)
                for i,value in enumerate(line):
                    if i>=9 and switcher is not None:
                        twoSnp=switcher.get(value,['N','N'])
                        hap1=dicHaplotypes[i+0.1]
                        hap2=dicHaplotypes[i+0.2]
                        hap1.updateHap(twoSnp[0])
                        hap2.updateHap(twoSnp[1])
                        
                    


##update derived information
snp2_index = snpClass.getIndexAtName('rs1229984')
snp3_index = snpClass.getIndexAtName('rs2066702')

for indv in dicHaplotypes: #{5.1:Haplotype(id,pop),5.2:Haplotype(id,pop)}
    hap = dicHaplotypes[indv]
    if hap.haplotype[snp2_index] == '1':
        hap.setDerived('2d')
    elif hap.haplotype[snp3_index] == '1':
        hap.setDerived('3d')
        

##update hapRegion (ADH1B gene)

def updateHapRegion(start_index,stop_index,regionName):
    dicHap = distinctHap(dicHaplotypes, start_index, stop_index) 
    if regionName == 'ADH1B':
        dicHap = {'10001000000001000001100100010010001001000000000001100001000000110000000000000000001100101000000000001': 728, '00000010000110000100000000001000000011010000000000000000000000000000000000101000000000000000000010001': 698, '10001000000001000001100100010010001001000000000001100001000000110000000000000000001100101010000000001': 686, '00011001000000000001100100010000000000000000000101000000000000010000000000000100011000000100000000000': 524, '00000000000000001000000000010100010001010000010010010000000000000000000100010000000000000000000000000': 468, '00011001000000000001100100010000000000000000000101001000000000010000000000000100011000000100000000000': 156, '10001000000001000001100100010010001001000000000001100001100000110010000000000000001100101000000000001': 135, '00000000010000000000000000010100110101010001010010000000000001000000000011010000000000000000000000000': 130, '00001100000000000001100100010001000001000000100001000000000000010100000000000000001001000100000000000': 116, '00001001000000100001100100010000000001101100000001000100010000010000010000000000101000000101001000000': 113, '00011001000000000001100100010000000000000000000101001000000000010000000000000101011000000100000000000': 109, '00000000110000000000000000010100110101010000010010000000000011000000000011010000000000000000000000000': 105, '00001000000000000001100100010000000001000000000001000000000000010000000000000010001000000000000000000': 93, '00001100000000000001100100010001000001000000000001000000000000010100000000000000001001000100000000000': 88, '01000010000010000000000000001000000011010000000000000000000000000000000000101000000000000000000100111': 69, '10001000000001010001100100010010001001000000000001100001000000110000000000000000001100101000000000001': 62, '00000000000000001000001000010100010001010000010010010000000000000000000100010000000000000000000000000': 56, '00000010000110000100000000001000000011010000000000000000000000000000000000101000000000000010000010001': 55, '10001000001001000001110100010010001001000010001001100001000000110000000000000000001100101000000000001': 55, '00001000000000000000000000010100010001010000010010000010000000001001000000010000000010000000100000000': 49, '00001000000000000001100100010000000001000000000001000000001000010000101000000000001000010000010000001': 44, '10001000000001000001100100010010001001000000000001100001000000110010000000000000001100101000000000001': 41, '10001000000001000001100100110010001001000000000001100001000000110000000000000000001100101000000000001': 40, '00011001000000000001100100010000000000000000000101000000000000010000000000000100011000000110000000000': 36, '00001001000000100001100100010000000001000000000001000100010000010000010000000000001000000101000000000': 35, '10001000000001000001100100010010001001000000000001100001000000110010000000000000001100101000000000000': 34, '00000010000110000100000000001000000111010000000000000000000000000000000000101000000000000000000010001': 32, '00101000000000000011100110010000000001000000000001000000000100010000000000000000001001000100000001001': 28, '00011001000000000001100101010000000000000000000101000000000000010000000000000100011000000100000000000': 16, '00000000010000000000000000010100110101010000010010000000000001000000000011010000000000000000000000000': 16, '00000000000000001000000000010100010001010000010010010000000000000000000100010000011000000000000000000': 15, '00001000000000000001100100010000000001000000000001000000000000010000000000000000001000000100000000000': 14, '00101000000000000011100110010000000001000000000001000000000100010000000000000000001001000100000000001': 13, '00001001000000100001100100010000000001100100000001000100010000010000010000000000001000000101000000000': 13, '10001000001001000001110100011010001001000010001001100001000000110000000000000000001100101000000000001': 11, '10001000000001000001100100010010001001000000000001100101010000010000000000000000001100101000000000000': 9, '00000010000110000000000000001000000011010000000000000000000000000000000000101000000000000000000010001': 7, '00000000010000000000000000010100010101010001010010000000000001000000000011010000000000000000000000000': 7, '00011001000000000001100100010000001001000000000001100001000000110000000000000000001100101010000000001': 5, '00000010000110000100000000001000000011010000000000000000000000000000000000101000001000000101000000000': 4, '10001000000001000001100100010010001001000000000001100001000000110000000000000000001100101000000000000': 3, '10001000000001000001100100010010001001000000000001100001100000110010000000000000001100101010000000001': 3, '00001100000000000001100100010000000001000000000001000000000000010100000000000000001001000100000000000': 3, '00000000110000000000000000010100010101010000010010000000000011000000000011010000000000000000000000000': 3, '00101000000000000011100110010000000001000000000001000000000100010000000000000000001001000100000001000': 3, '01000010000010000000000000001000000011010000000000000000000000000000000000101000000000000000000100110': 3, '00001100000000000001100100010001000001000000000001000000000000010000000000000000001001000100000000000': 3, '00011001000000000001100100010000000000000000000101000000000000010000000000000100011000000000000000000': 2, '00000010000110000100000000001000000011010000000000000000000000000000000000101000000000001000000000001': 2, '00000000000000001000000000010100010001010000010010010000000000000000000100010000000000000000000000001': 2, '10001000000001000001100100010010001001000000000001100001000000110000000000000000001100101010000000000': 2, '10001000000001000001100100010010001101000000000001100001000000110010000000000000001100101000000000001': 2, '00001000000000000011100110010000000001000000000001000000000000010000000000000000001001000100000000001': 2, '00000000110000000000000000010100110101010000000010000000000011000000000011010000000000000000000000000': 2, '00001100000000000001100100010001000001000000000001000000000000010100000000000100001001000100000000000': 2, '10001000001001000001100100010010001001000000000001100001000000110000000000000000001100101000000000001': 2, '10001001000000100001100100010000000001101100000001000100010000010000010000000000101000000101001000000': 1, '00001001000000100001100100010000000001101100000001000100010000010000010000000000101000000101000000000': 1, '10001000000001010001100100010010001001000000000001100001000000110000000000000000001100100101001000000': 1, '10001000000001000001100100110010001001000000000001100001000000110010000000000000001100101000000000001': 1, '10001000000001000001100100010010001001000100000001100001000000110000000000000000001100101000000000001': 1, '10001000000001000001100100010000000001000000000001000000000000010000000000000010001000000000000000000': 1, '10001000000001010001100100010010001001000010000001100001000000110000000000000000001100101000000000001': 1, '10001000000001000001100100010010001001000000000001100001000000110000010000000000001100101000000000001': 1, '00011001010000000001100100010000000000000000000101000000000000010000000000000100011000000100000000000': 1, '00001001000000100001100100010000001001101100000001000100010000010000010000000000101000000101001000000': 1, '10001000000001000001000100010010001001000000000001100001100000110010000000000000001100101000000000001': 1, '00001001000000100001100100010010000001101100000001000100010000010000010000000000101000000101001000000': 1, '00000000000110000100000000010100010001010000010010010000000000000000000100010000000000000000000010001': 1, '10001000000001000001100100010010001001000000000001100001000000110000000000001000001100101000000000001': 1, '00000000000000001000000000010010001001000000000001100001000000110000000000000000001100101000000000001': 1, '00011001000000000001100100010000000001101100000001000100010000010000010000000000101000000101001000000': 1, '10001000000001000001100100010010001001100000000001100001000000110010000000000000001100101000000000001': 1, '00000010000000001000000000010100010001010000010010010000000000000000000100010000011000000000000000000': 1, '10001000000001000001100100010010001001000000000001100001100000110010000000000000001100101000000010001': 1, '00000000000000001000000000010100010101010000010010010000000000000000000100010000000000000000000000000': 1, '10001000000001000001100100010000000000000000000101000000000000010000000000000000011100101010000000001': 1, '10001000000001000001100100010010001001000000000001100001000000110000000000000000001100001000000000000': 1, '00011001000000000001100100010000000000000000000101000000000000010000000000000100011000000100000010001': 1, '10001000000001000001100100010000001001000000000001100001000000110000000000000000001100101010000000001': 1, '10001000000001000001100100010010001001000000000001100001000000110000000000000000001100101110000000001': 1, '10001000000001000001100100010010001011000000000001100001000000110000000000000000001100101010000000001': 1, '10001000010001000001100100010010001001000000000001100001000000110000000000000000001100101010000000001': 1, '10000000000001000001100100010010001001000000000001100001000000110000000000000000001100101010000000001': 1, '00011001000000000001100100010000000000000000000101000000000000010000000100010100011000000100000000000': 1, '00011001000000000001100100010000000000000000000101000000000000010000000000000100011100101000000000001': 1, '00001001000000100001100100010000000000000000000101000000000000010000000000000100011000000110000000000': 1, '10001000000001000001100100010010001001000000000001100001100000110010000000000000001100100100000000000': 1, '00011001000000000101100100010000000000000000000101000000000000010000000000000100011000000100000000000': 1, '00001000000000000001100100010000000001000000000001000000000000010000000000000010001000000000000000001': 1, '10001000000001000001100100010010001001000000000001100001100000110010000000000000001100100000000000001': 1, '00000000000000001000000000010100010001010000010010010000000000000000000100010000000000000000000010001': 1, '00000000110000000000000000010100110101010000010010000000000011000000000000010000000000000000000000000': 1, '00001000000000000000000000010100010001010000010010000010000000001001000000010000001010000000100000000': 1, '00000010000110000100000000001000000011010000000000000000000000000000000000101000000000000000000000000': 1, '00001100000000000001100100010001000001000000000001000000000000010100000000000000001001000100000000001': 1, '00101000000000000011100110010001000001000000000001000000000000010000000000000000001001000100000000001': 1, '00011001000000000001100100010000000000000000000101000000000000010000000000001100011000000100000000000': 1, '10001000001001000001110100010010000001000000000001000000001000010000101000000000001000010000010000001': 1, '00001100000000000001100100010000000000000000000101001000000000010000000000000101011000000100000000000': 1, '00001100000000000011100110010001000001000000000001000000000000010100000000000000001001000100000000000': 1, '10001000001001000001110100010010001001000010001001100001000000110000000000000000001100101000000000000': 1, '00000000110000000000000000010100110101010000010010000000000011000000000011010000000000001000000000000': 1, '00001010000000000001100100010000000001000000000001000000000000010000000000000000001000000000000000000': 1, '00000000010000000000000000010100110101010001010010000000000001000000000011010000000000000101000000000': 1, '00001100000000000001100100010001010001010000010010010000000000000100000000000000001001000000000000000': 1, '00001100000000000001100100010000000001000000000001000000000000010000000000000000001001000100000000000': 1, '00000000010000000000000000010000110101010001010010000000000001000000000011010000000000000000000000000': 1, '00001000000000000001100100010000000001000000000001000000000000010000000000000000001001000100000000000': 1, '10001000000001000000000000010100011001000000010010100010000000001001000000000000001100101000000000001': 1}
    hapName = nameHap(dicHap) #{h1:0,h2:1}
    dicGroup = clustering(dicHap) #kmeans clustering {0:h1,h2}
    #print(convertdicGroup(hapName,dicGroup))
    for indv in dicHaplotypes: #{5.1:Haplotype(id,pop),5.2:Haplotype(id,pop)}
        hapRegion = HapRegion(start_index,stop_index)
        haplotype = dicHaplotypes[indv]
        region = haplotype.getRegion(start_index,stop_index)
        hapRegion.setRegionName(regionName)
        hapNum = findName(region,hapName)
        hapRegion.setHapNum(hapNum)
        group = findGroup(region,dicGroup)
        hapRegion.setGroup(group)
        haplotype.addRegion(hapRegion)        
    return dicGroup
       
regionName = 'ADH1B'
start_index = snpClass.getIndexAtPos(100216151)
stop_index = snpClass.getIndexAtPos(100243009)

#start_index = snpClass.getIndexAtPos(100243875)
#stop_index = snpClass.getIndexAtPos(100264058)
dicGroupB = updateHapRegion(start_index,stop_index,regionName)

#print(dicGroup)
print('done!')
                    
                    
   
